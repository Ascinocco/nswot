import { ok, err } from '../domain/result';
import type { Result } from '../domain/result';
import { DomainError, ERROR_CODES } from '../domain/errors';
import type { Analysis, SwotItem, AnalysisProfile } from '../domain/types';
import type { AnalysisRepository } from '../repositories/analysis.repository';

export class ExportService {
  constructor(private readonly analysisRepo: AnalysisRepository) {}

  async exportMarkdown(analysisId: string): Promise<Result<string, DomainError>> {
    try {
      const analysis = await this.analysisRepo.findById(analysisId);
      if (!analysis) {
        return err(
          new DomainError(ERROR_CODES.INTERNAL_ERROR, `Analysis "${analysisId}" not found`),
        );
      }
      if (analysis.status !== 'completed' || !analysis.swotOutput) {
        return err(
          new DomainError(ERROR_CODES.INTERNAL_ERROR, 'Analysis is not completed'),
        );
      }

      const profiles = await this.analysisRepo.findProfiles(analysisId);
      const markdown = buildMarkdown(analysis, profiles);
      return ok(markdown);
    } catch (cause) {
      if (cause instanceof DomainError) {
        return err(cause);
      }
      return err(
        new DomainError(ERROR_CODES.INTERNAL_ERROR, 'Failed to export analysis', cause),
      );
    }
  }
}

function buildMarkdown(analysis: Analysis, profiles: AnalysisProfile[]): string {
  const sections: string[] = [];
  const role =
    analysis.role === 'staff_engineer' ? 'Staff Engineer' : 'Senior Engineering Manager';
  const date = analysis.completedAt
    ? new Date(analysis.completedAt).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      })
    : 'Unknown';

  // Header
  sections.push(`# SWOT Analysis

| Field | Value |
|-------|-------|
| **Date** | ${date} |
| **Role** | ${role} |
| **Model** | ${analysis.modelId} |
| **Profiles** | ${profiles.length} stakeholders |`);

  if (analysis.warning) {
    sections.push(`\n> **Warning:** ${analysis.warning}`);
  }

  // Summaries
  if (analysis.summariesOutput) {
    sections.push(`\n---\n\n## Executive Summary\n\n### Stakeholder Themes\n\n${analysis.summariesOutput.profiles}\n\n### Jira Patterns\n\n${analysis.summariesOutput.jira}`);
  }

  // SWOT Quadrants
  const swot = analysis.swotOutput!;
  sections.push('\n---\n');

  sections.push(formatQuadrant('Strengths', swot.strengths));
  sections.push(formatQuadrant('Weaknesses', swot.weaknesses));
  sections.push(formatQuadrant('Opportunities', swot.opportunities));
  sections.push(formatQuadrant('Threats', swot.threats));

  // Stakeholder key
  if (profiles.length > 0) {
    sections.push('---\n\n## Stakeholder Key\n');
    sections.push(
      '| Label | Role |',
      '|-------|------|',
    );
    // Note: we only have anonymized labels here, not real names (by design)
    for (const p of profiles) {
      sections.push(`| ${p.anonymizedLabel} | â€” |`);
    }
  }

  // Footer
  sections.push(
    '\n---\n\n*Generated by nswot*',
  );

  return sections.join('\n');
}

function formatQuadrant(title: string, items: SwotItem[]): string {
  const sections: string[] = [`## ${title}\n`];

  if (items.length === 0) {
    sections.push('*No items identified.*\n');
    return sections.join('\n');
  }

  for (let i = 0; i < items.length; i++) {
    const item = items[i]!;
    const badge = confidenceBadge(item.confidence);

    sections.push(`### ${i + 1}. ${item.claim} ${badge}\n`);
    sections.push(`**Impact:** ${item.impact}\n`);
    sections.push(`**Recommendation:** ${item.recommendation}\n`);

    if (item.evidence.length > 0) {
      sections.push('**Evidence:**\n');
      for (const e of item.evidence) {
        sections.push(`- \\[${e.sourceId}\\] "${e.quote}"`);
      }
      sections.push('');
    }
  }

  return sections.join('\n');
}

function confidenceBadge(confidence: string): string {
  switch (confidence) {
    case 'high':
      return '`HIGH`';
    case 'medium':
      return '`MEDIUM`';
    case 'low':
      return '`LOW`';
    default:
      return `\`${confidence.toUpperCase()}\``;
  }
}
