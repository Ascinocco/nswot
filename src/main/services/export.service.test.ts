import { describe, it, expect, vi, beforeEach } from 'vitest';
import { ExportService } from './export.service';
import type { AnalysisRepository } from '../repositories/analysis.repository';
import type { Analysis, AnalysisProfile } from '../domain/types';

function makeCompletedAnalysis(overrides?: Partial<Analysis>): Analysis {
  return {
    id: 'analysis-1',
    workspaceId: 'ws-1',
    role: 'staff_engineer',
    modelId: 'openai/gpt-4',
    status: 'completed',
    config: { profileIds: ['p1', 'p2'], jiraProjectKeys: ['PROJ'], confluenceSpaceKeys: [], githubRepos: [], codebaseRepos: [] },
    inputSnapshot: null,
    swotOutput: {
      strengths: [
        {
          claim: 'Strong technical leadership',
          evidence: [
            {
              sourceType: 'profile',
              sourceId: 'profile:Stakeholder A',
              sourceLabel: 'Stakeholder A',
              quote: 'Great technical depth',
            },
          ],
          impact: 'Enables complex initiatives',
          recommendation: 'Leverage for reviews',
          confidence: 'high',
        },
      ],
      weaknesses: [
        {
          claim: 'Slow CI pipeline',
          evidence: [
            {
              sourceType: 'profile',
              sourceId: 'profile:Stakeholder B',
              sourceLabel: 'Stakeholder B',
              quote: 'CI takes 47 minutes',
            },
          ],
          impact: 'Reduced productivity',
          recommendation: 'Parallelize builds',
          confidence: 'medium',
        },
      ],
      opportunities: [],
      threats: [],
    },
    summariesOutput: {
      profiles: 'Key themes include technical leadership and CI concerns.',
      jira: 'Active sprint with migration epic.',
      confluence: null,
      github: null,
      codebase: null,
    },
    qualityMetrics: null,
    rawLlmResponse: '{}',
    warning: null,
    error: null,
    startedAt: '2024-01-01T00:00:00.000Z',
    completedAt: '2024-06-15T10:30:00.000Z',
    conversationId: null,
    parentAnalysisId: null,
    createdAt: '2024-01-01T00:00:00.000Z',
    ...overrides,
  };
}

const mockProfiles: AnalysisProfile[] = [
  { analysisId: 'analysis-1', profileId: 'p1', anonymizedLabel: 'Stakeholder A' },
  { analysisId: 'analysis-1', profileId: 'p2', anonymizedLabel: 'Stakeholder B' },
];

describe('ExportService', () => {
  let analysisRepo: AnalysisRepository;
  let service: ExportService;

  beforeEach(() => {
    analysisRepo = {
      findById: vi.fn().mockResolvedValue(makeCompletedAnalysis()),
      findProfiles: vi.fn().mockResolvedValue(mockProfiles),
    } as unknown as AnalysisRepository;

    service = new ExportService(analysisRepo);
  });

  it('generates markdown with header metadata', async () => {
    const result = await service.exportMarkdown('analysis-1');
    expect(result.ok).toBe(true);
    if (result.ok) {
      expect(result.value).toContain('# SWOT Analysis');
      expect(result.value).toContain('Staff Engineer');
      expect(result.value).toContain('openai/gpt-4');
      expect(result.value).toContain('2 stakeholders');
    }
  });

  it('includes summaries section', async () => {
    const result = await service.exportMarkdown('analysis-1');
    if (result.ok) {
      expect(result.value).toContain('Executive Summary');
      expect(result.value).toContain('technical leadership and CI concerns');
      expect(result.value).toContain('migration epic');
    }
  });

  it('includes SWOT quadrants with evidence', async () => {
    const result = await service.exportMarkdown('analysis-1');
    if (result.ok) {
      expect(result.value).toContain('## Strengths');
      expect(result.value).toContain('Strong technical leadership');
      expect(result.value).toContain('`HIGH`');
      expect(result.value).toContain('Great technical depth');
      expect(result.value).toContain('## Weaknesses');
      expect(result.value).toContain('Slow CI pipeline');
      expect(result.value).toContain('`MEDIUM`');
      expect(result.value).toContain('## Opportunities');
      expect(result.value).toContain('## Threats');
    }
  });

  it('includes empty quadrant placeholder', async () => {
    const result = await service.exportMarkdown('analysis-1');
    if (result.ok) {
      expect(result.value).toContain('*No items identified.*');
    }
  });

  it('includes stakeholder key', async () => {
    const result = await service.exportMarkdown('analysis-1');
    if (result.ok) {
      expect(result.value).toContain('Stakeholder Key');
      expect(result.value).toContain('Stakeholder A');
      expect(result.value).toContain('Stakeholder B');
    }
  });

  it('includes footer', async () => {
    const result = await service.exportMarkdown('analysis-1');
    if (result.ok) {
      expect(result.value).toContain('Generated by nswot');
    }
  });

  it('includes warning when present', async () => {
    vi.mocked(analysisRepo.findById).mockResolvedValue(
      makeCompletedAnalysis({ warning: 'Stale cache used' }),
    );
    const result = await service.exportMarkdown('analysis-1');
    if (result.ok) {
      expect(result.value).toContain('Stale cache used');
    }
  });

  it('returns error when analysis not found', async () => {
    vi.mocked(analysisRepo.findById).mockResolvedValue(null);
    const result = await service.exportMarkdown('nonexistent');
    expect(result.ok).toBe(false);
    if (!result.ok) {
      expect(result.error.code).toBe('INTERNAL_ERROR');
    }
  });

  it('returns error when analysis is not completed', async () => {
    vi.mocked(analysisRepo.findById).mockResolvedValue(
      makeCompletedAnalysis({ status: 'running', swotOutput: null }),
    );
    const result = await service.exportMarkdown('analysis-1');
    expect(result.ok).toBe(false);
  });

  it('formats senior EM role correctly', async () => {
    vi.mocked(analysisRepo.findById).mockResolvedValue(
      makeCompletedAnalysis({ role: 'senior_em' }),
    );
    const result = await service.exportMarkdown('analysis-1');
    if (result.ok) {
      expect(result.value).toContain('Senior Engineering Manager');
    }
  });

  it('formats VP of Engineering role correctly', async () => {
    vi.mocked(analysisRepo.findById).mockResolvedValue(
      makeCompletedAnalysis({ role: 'vp_engineering' }),
    );
    const result = await service.exportMarkdown('analysis-1');
    if (result.ok) {
      expect(result.value).toContain('VP of Engineering');
    }
  });

  describe('exportCSV', () => {
    it('produces CSV with correct headers', async () => {
      const result = await service.exportCSV('analysis-1');
      expect(result.ok).toBe(true);
      if (!result.ok) return;

      const lines = result.value.split('\n');
      expect(lines[0]).toBe('quadrant,claim,confidence,evidence_count,recommendation,sources');
    });

    it('includes all SWOT items with correct quadrant labels', async () => {
      const result = await service.exportCSV('analysis-1');
      expect(result.ok).toBe(true);
      if (!result.ok) return;

      const lines = result.value.split('\n');
      // Header + 1 strength + 1 weakness + 0 opp + 0 threats = 3 lines
      expect(lines).toHaveLength(3);
      expect(lines[1]).toContain('Strengths');
      expect(lines[1]).toContain('Strong technical leadership');
      expect(lines[1]).toContain('high');
      expect(lines[2]).toContain('Weaknesses');
      expect(lines[2]).toContain('Slow CI pipeline');
    });

    it('includes correct evidence count', async () => {
      const result = await service.exportCSV('analysis-1');
      expect(result.ok).toBe(true);
      if (!result.ok) return;

      const lines = result.value.split('\n');
      // Strengths row: 1 evidence entry
      expect(lines[1]).toContain(',1,');
    });

    it('escapes CSV values with commas', async () => {
      vi.mocked(analysisRepo.findById).mockResolvedValue(
        makeCompletedAnalysis({
          swotOutput: {
            strengths: [
              {
                claim: 'Test, with commas',
                evidence: [],
                impact: 'None',
                recommendation: 'Fix it',
                confidence: 'low',
              },
            ],
            weaknesses: [],
            opportunities: [],
            threats: [],
          },
        }),
      );
      const result = await service.exportCSV('analysis-1');
      expect(result.ok).toBe(true);
      if (!result.ok) return;
      expect(result.value).toContain('"Test, with commas"');
    });

    it('returns error for non-existent analysis', async () => {
      vi.mocked(analysisRepo.findById).mockResolvedValue(null);
      const result = await service.exportCSV('missing');
      expect(result.ok).toBe(false);
    });

    it('returns error for incomplete analysis', async () => {
      vi.mocked(analysisRepo.findById).mockResolvedValue(
        makeCompletedAnalysis({ status: 'running', swotOutput: null }),
      );
      const result = await service.exportCSV('analysis-1');
      expect(result.ok).toBe(false);
    });
  });

  describe('exportPDF', () => {
    it('produces a non-empty Buffer', async () => {
      const result = await service.exportPDF('analysis-1');
      expect(result.ok).toBe(true);
      if (!result.ok) return;

      expect(result.value).toBeInstanceOf(Buffer);
      expect(result.value.length).toBeGreaterThan(0);
    });

    it('produces a valid PDF (starts with %PDF)', async () => {
      const result = await service.exportPDF('analysis-1');
      expect(result.ok).toBe(true);
      if (!result.ok) return;

      const header = result.value.subarray(0, 5).toString('ascii');
      expect(header).toBe('%PDF-');
    });

    it('returns error for non-existent analysis', async () => {
      vi.mocked(analysisRepo.findById).mockResolvedValue(null);
      const result = await service.exportPDF('missing');
      expect(result.ok).toBe(false);
    });

    it('returns error for incomplete analysis', async () => {
      vi.mocked(analysisRepo.findById).mockResolvedValue(
        makeCompletedAnalysis({ status: 'failed', swotOutput: null }),
      );
      const result = await service.exportPDF('analysis-1');
      expect(result.ok).toBe(false);
    });
  });
});
