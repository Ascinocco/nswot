import { describe, it, expect, vi, beforeEach } from 'vitest';
import { ExportService } from './export.service';
import type { AnalysisRepository } from '../repositories/analysis.repository';
import type { Analysis, AnalysisProfile } from '../domain/types';

function makeCompletedAnalysis(overrides?: Partial<Analysis>): Analysis {
  return {
    id: 'analysis-1',
    workspaceId: 'ws-1',
    role: 'staff_engineer',
    modelId: 'openai/gpt-4',
    status: 'completed',
    config: { profileIds: ['p1', 'p2'], jiraProjectKeys: ['PROJ'], confluenceSpaceKeys: [], githubRepos: [], codebaseRepos: [] },
    inputSnapshot: null,
    swotOutput: {
      strengths: [
        {
          claim: 'Strong technical leadership',
          evidence: [
            {
              sourceType: 'profile',
              sourceId: 'profile:Stakeholder A',
              sourceLabel: 'Stakeholder A',
              quote: 'Great technical depth',
            },
          ],
          impact: 'Enables complex initiatives',
          recommendation: 'Leverage for reviews',
          confidence: 'high',
        },
      ],
      weaknesses: [
        {
          claim: 'Slow CI pipeline',
          evidence: [
            {
              sourceType: 'profile',
              sourceId: 'profile:Stakeholder B',
              sourceLabel: 'Stakeholder B',
              quote: 'CI takes 47 minutes',
            },
          ],
          impact: 'Reduced productivity',
          recommendation: 'Parallelize builds',
          confidence: 'medium',
        },
      ],
      opportunities: [],
      threats: [],
    },
    summariesOutput: {
      profiles: 'Key themes include technical leadership and CI concerns.',
      jira: 'Active sprint with migration epic.',
      confluence: null,
      github: null,
      codebase: null,
    },
    qualityMetrics: null,
    rawLlmResponse: '{}',
    warning: null,
    error: null,
    startedAt: '2024-01-01T00:00:00.000Z',
    completedAt: '2024-06-15T10:30:00.000Z',
    createdAt: '2024-01-01T00:00:00.000Z',
    ...overrides,
  };
}

const mockProfiles: AnalysisProfile[] = [
  { analysisId: 'analysis-1', profileId: 'p1', anonymizedLabel: 'Stakeholder A' },
  { analysisId: 'analysis-1', profileId: 'p2', anonymizedLabel: 'Stakeholder B' },
];

describe('ExportService', () => {
  let analysisRepo: AnalysisRepository;
  let service: ExportService;

  beforeEach(() => {
    analysisRepo = {
      findById: vi.fn().mockResolvedValue(makeCompletedAnalysis()),
      findProfiles: vi.fn().mockResolvedValue(mockProfiles),
    } as unknown as AnalysisRepository;

    service = new ExportService(analysisRepo);
  });

  it('generates markdown with header metadata', async () => {
    const result = await service.exportMarkdown('analysis-1');
    expect(result.ok).toBe(true);
    if (result.ok) {
      expect(result.value).toContain('# SWOT Analysis');
      expect(result.value).toContain('Staff Engineer');
      expect(result.value).toContain('openai/gpt-4');
      expect(result.value).toContain('2 stakeholders');
    }
  });

  it('includes summaries section', async () => {
    const result = await service.exportMarkdown('analysis-1');
    if (result.ok) {
      expect(result.value).toContain('Executive Summary');
      expect(result.value).toContain('technical leadership and CI concerns');
      expect(result.value).toContain('migration epic');
    }
  });

  it('includes SWOT quadrants with evidence', async () => {
    const result = await service.exportMarkdown('analysis-1');
    if (result.ok) {
      expect(result.value).toContain('## Strengths');
      expect(result.value).toContain('Strong technical leadership');
      expect(result.value).toContain('`HIGH`');
      expect(result.value).toContain('Great technical depth');
      expect(result.value).toContain('## Weaknesses');
      expect(result.value).toContain('Slow CI pipeline');
      expect(result.value).toContain('`MEDIUM`');
      expect(result.value).toContain('## Opportunities');
      expect(result.value).toContain('## Threats');
    }
  });

  it('includes empty quadrant placeholder', async () => {
    const result = await service.exportMarkdown('analysis-1');
    if (result.ok) {
      expect(result.value).toContain('*No items identified.*');
    }
  });

  it('includes stakeholder key', async () => {
    const result = await service.exportMarkdown('analysis-1');
    if (result.ok) {
      expect(result.value).toContain('Stakeholder Key');
      expect(result.value).toContain('Stakeholder A');
      expect(result.value).toContain('Stakeholder B');
    }
  });

  it('includes footer', async () => {
    const result = await service.exportMarkdown('analysis-1');
    if (result.ok) {
      expect(result.value).toContain('Generated by nswot');
    }
  });

  it('includes warning when present', async () => {
    vi.mocked(analysisRepo.findById).mockResolvedValue(
      makeCompletedAnalysis({ warning: 'Stale cache used' }),
    );
    const result = await service.exportMarkdown('analysis-1');
    if (result.ok) {
      expect(result.value).toContain('Stale cache used');
    }
  });

  it('returns error when analysis not found', async () => {
    vi.mocked(analysisRepo.findById).mockResolvedValue(null);
    const result = await service.exportMarkdown('nonexistent');
    expect(result.ok).toBe(false);
    if (!result.ok) {
      expect(result.error.code).toBe('INTERNAL_ERROR');
    }
  });

  it('returns error when analysis is not completed', async () => {
    vi.mocked(analysisRepo.findById).mockResolvedValue(
      makeCompletedAnalysis({ status: 'running', swotOutput: null }),
    );
    const result = await service.exportMarkdown('analysis-1');
    expect(result.ok).toBe(false);
  });

  it('formats senior EM role correctly', async () => {
    vi.mocked(analysisRepo.findById).mockResolvedValue(
      makeCompletedAnalysis({ role: 'senior_em' }),
    );
    const result = await service.exportMarkdown('analysis-1');
    if (result.ok) {
      expect(result.value).toContain('Senior Engineering Manager');
    }
  });
});
